// --- DOM Elements ---
const video = document.getElementById('video');
const scanButton = document.getElementById('scanButton');
const canvas = document.getElementById('canvas');
const resultsPanel = document.getElementById('results-panel');
const closeButton = document.getElementById('close-results');
const outputEl = document.getElementById('output');
const totalScoreEl = document.getElementById('total-score');
const overlay = document.getElementById('scan-overlay');

// --- State and Constants ---
const letterScores = {
    'A': 1, 'B': 3, 'C': 3, 'D': 2, 'E': 1, 'F': 4, 'G': 2, 'H': 4, 'I': 1,
    'J': 8, 'K': 5, 'L': 1, 'M': 3, 'N': 1, 'O': 1, 'P': 3, 'Q': 10, 'R': 1,
    'S': 1, 'T': 1, 'U': 1, 'V': 4, 'W': 4, 'X': 8, 'Y': 4, 'Z': 10
};
let dictionary = new Set();
let scannedWords = new Set(); // Use a Set to avoid duplicate words
let totalScore = 0;
let tesseractScheduler;

// --- Initialization ---
async function initialize() {
    await setupCamera();
    await loadDictionary();
    tesseractScheduler = Tesseract.createScheduler();
    const worker = await Tesseract.createWorker('eng');
    tesseractScheduler.addWorker(worker);
    scanButton.textContent = 'Scan';
    scanButton.disabled = false;
}

async function loadDictionary() {
    try {
        const response = await fetch('dictionary.txt');
        const text = await response.text();
        dictionary = new Set(text.split('\n').map(word => word.trim().toLowerCase()));
    } catch (error) {
        console.error('Dictionary load error:', error);
        alert('Could not load dictionary. Please check the connection and refresh.');
    }
}

async function setupCamera() {
    try {
        const stream = await navigator.mediaDevices.getUserMedia({
            video: { facingMode: 'environment' }
        });
        video.srcObject = stream;
        
        await new Promise(resolve => {
            video.onloadedmetadata = () => {
                video.play(); // Start playing the video

                // Check if the video stream is wider than it is tall (landscape)
                // This is common for rear cameras even when the phone is held in portrait.
                const isStreamLandscape = video.videoWidth > video.videoHeight;
                
                // Apply rotation and centering transform if the stream is landscape
                // and we assume the device is held in portrait.
                if (isStreamLandscape) {
                    // Rotate 90 degrees and center. The order of transforms matters.
                    // translate(-50%, -50%) centers the element, then rotate it.
                    video.style.transform = 'translate(-50%, -50%) rotate(90deg)';
                } else {
                    // If stream is already portrait or square, just center it
                    video.style.transform = 'translate(-50%, -50%)';
                }
                resolve();
            };
        });
    } catch (err) {
        console.error("Error accessing camera: ", err);
        alert('Could not access camera. Please grant permission and refresh.');
    }
}

// --- UI Interaction ---
scanButton.addEventListener('click', handleScan);
closeButton.addEventListener('click', () => resultsPanel.classList.remove('visible'));

// --- Core Logic ---
async function handleScan() {
    scanButton.disabled = true;
    scanButton.textContent = '...';

    // Get the guide box's position relative to the viewport
    const guideRect = overlay.getBoundingClientRect();
    
    // Calculate the crop area based on the video's actual dimensions
    const videoWidth = video.videoWidth;
    const videoHeight = video.videoHeight;
    const viewWidth = window.innerWidth;
    const viewHeight = window.innerHeight;

    // Determine the effective scale factor, considering potential video rotation
    let effectiveVideoWidth = videoWidth;
    let effectiveVideoHeight = videoHeight;
    if (video.style.transform.includes('rotate(90deg)')) {
        // If rotated, swap width and height for calculation purposes
        effectiveVideoWidth = videoHeight;
        effectiveVideoHeight = videoWidth;
    }

    // Calculate the scale factor between the *effective* video dimensions and the viewport
    // This is more complex because object-fit: cover might crop.
    // A simpler approach is to draw the full video to a temporary canvas, then crop from there.
    // Let's stick to the direct crop from video for now, but be aware of potential edge cases.

    // For cropping, we need to consider the video's current display size and position
    // relative to the viewport, and then map that back to the intrinsic video pixels.
    // This is a common source of error. Let's refine the cropping logic.

    // Create a temporary canvas to draw the *visible* portion of the video
    // This handles object-fit: cover and rotation more reliably for cropping.
    const tempCanvas = document.createElement('canvas');
    const tempCtx = tempCanvas.getContext('2d');

    // Calculate the aspect ratios
    const videoAspectRatio = videoWidth / videoHeight;
    const containerAspectRatio = viewWidth / viewHeight;

    let sx, sy, sWidth, sHeight; // Source rectangle on the video
    let dx, dy, dWidth, dHeight; // Destination rectangle on the tempCanvas

    tempCanvas.width = viewWidth;
    tempCanvas.height = viewHeight;

    // Calculate how the video is actually rendered by object-fit: cover
    if (videoAspectRatio > containerAspectRatio) { // Video is wider than container
        sHeight = videoHeight;
        sWidth = videoHeight * containerAspectRatio;
        sx = (videoWidth - sWidth) / 2;
        sy = 0;
    } else { // Video is taller than container
        sWidth = videoWidth;
        sHeight = videoWidth / containerAspectRatio;
        sx = 0;
        sy = (videoHeight - sHeight) / 2;
    }

    // Draw the visible portion of the video to the temporary canvas
    tempCtx.drawImage(video, sx, sy, sWidth, sHeight, 0, 0, tempCanvas.width, tempCanvas.height);

    // Now, crop from this temporary canvas using the guideRect
    canvas.width = guideRect.width;
    canvas.height = guideRect.height;
    const ctx = canvas.getContext('2d');
    ctx.drawImage(tempCanvas, guideRect.left, guideRect.top, guideRect.width, guideRect.height, 0, 0, canvas.width, canvas.height);


    // Perform OCR on the cropped canvas
    const { data: { text } } = await tesseractScheduler.addJob('recognize', canvas, {
        // Tell Tesseract to treat the image as a single line of text. This is crucial!
        tessedit_pageseg_mode: Tesseract.PSM.SINGLE_LINE,
    });

    processRecognizedText(text);

    scanButton.disabled = false;
    scanButton.textContent = 'Scan';
}

function processRecognizedText(text) {
    // Clean up the recognized text: uppercase, remove non-alphabetic chars, take the first "word"
    const word = text.trim().toUpperCase().replace(/[^A-Z]/g, '');

    if (word.length < 2 || scannedWords.has(word)) {
        // Ignore short words, empty strings, or duplicates
        return;
    }

    scannedWords.add(word);
    const isValid = dictionary.has(word.toLowerCase());
    
    const wordDiv = document.createElement('div');
    wordDiv.classList.add('word-item');

    if (isValid) {
        const score = Array.from(word).reduce((acc, char) => acc + (letterScores[char] || 0), 0);
        totalScore += score;
        wordDiv.classList.add('valid');
        wordDiv.textContent = `${word} - Score: ${score}`;
    } else {
        wordDiv.classList.add('invalid');
        wordDiv.textContent = `${word} - (Invalid)`;
    }

    // Add the new word to the top of the list
    outputEl.prepend(wordDiv);
    updateTotalScore();
    
    // Show the results panel if it's not already visible
    if (!resultsPanel.classList.contains('visible')) {
        resultsPanel.classList.add('visible');
    }
}

function updateTotalScore() {
    totalScoreEl.textContent = `Total Score: ${totalScore}`;
}

// --- Start the App ---
scanButton.disabled = true;
scanButton.textContent = '...';
initialize();
